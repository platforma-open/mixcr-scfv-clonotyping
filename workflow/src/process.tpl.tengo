// process

self := import("@platforma-sdk/workflow-tengo:tpl")

ll := import("@platforma-sdk/workflow-tengo:ll")
assets := import("@platforma-sdk/workflow-tengo:assets")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
smart := import("@platforma-sdk/workflow-tengo:smart")
slices := import("@platforma-sdk/workflow-tengo:slices")
maps := import("@platforma-sdk/workflow-tengo:maps")
file := import("@platforma-sdk/workflow-tengo:file")
llPFrames := import("@platforma-sdk/workflow-tengo:pframes.ll")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")
pUtil := import("@platforma-sdk/workflow-tengo:pframes.util")
pConstants := import("@platforma-sdk/workflow-tengo:pframes.constants")

mixcrExports := import(":mixcr-exports")

json := import("json")
text := import("text")
render := import("@platforma-sdk/workflow-tengo:render")

mixcrAnalyzeTpl := assets.importTemplate(":mixcr-analyze")
aggClonesTpl := assets.importTemplate(":agg-clones")
exportReportTpl := assets.importTemplate(":export-report")

self.awaitState("InputsLocked")
self.awaitState("inputSpec", "ResourceReady")

constructColumns := func(linker, hinge, blockId) {
	columns := []

	for alphabet in ["nt", "aa"] {
		columns += [{
			column: "construct-" + alphabet,
			id: "construct-" + alphabet,
			naRegex: "",
			spec: {
				name: "pl7.app/vdj/scFv-sequence",
				valueType: "String",
				domain: {
					"pl7.app/alphabet": alphabet == "nt" ? "nucleotide" : "aminoacid",
					"pl7.app/vdj/scFv-linker": linker,
					"pl7.app/vdj/scFv-hinge": hinge,
					"pl7.app/vdj/clonotypingRunId": blockId
				},
				annotations: {
					"pl7.app/label": "scFv sequence " + alphabet,
					"pl7.app/table/orderPriority": "80000",
					"pl7.app/vdj/isAssemblingFeature": "true",
					"pl7.app/vdj/isMainSequence": "true",
					"pl7.app/vdj/isAssemblingFeature": "true",
					"pl7.app/table/visibility": alphabet == "aa" ? "default" : "optional"
				}
			}
		}]
	}

	columns += [{
		column: "isProductive",
		id: "isProductive",
		naRegex: "",
		spec: {
			name: "pl7.app/vdj/sequence/productive",
			valueType: "String",
			domain: {
				"pl7.app/vdj/scFv-linker": linker,
				"pl7.app/vdj/scFv-hinge": hinge,
				"pl7.app/vdj/clonotypingRunId": blockId
			},
			annotations: {
				"pl7.app/label": "Productive",
				"pl7.app/table/orderPriority": "40000",
				"pl7.app/isDiscreteFilter": "true",
				"pl7.app/discreteValues": string(json.encode(["true", "false"])),
				"pl7.app/table/visibility": "optional"
			}
		}
	}]

	return columns
}

clonotypeKeyLabelColumns := func(blockId) {
	return [{
		column: "clonotypeLabel",
		id: "clonotypeLabel",
		naRegex: "",
		spec: {
			name: "pl7.app/label",
			valueType: "String",
			domain: {
				"pl7.app/vdj/clonotypingRunId": blockId
			},
			annotations: {
				"pl7.app/label": "scFv label",
				"pl7.app/table/visibility": "default"
				//"pl7.app/table/orderPriority": "200000"
			}
		}
	}]
}

self.body(func(inputs) {

	inputSpec := inputs.inputSpec
	blockId := inputs.blockId

	fileExtension := inputSpec.domain["pl7.app/fileExtension"]

	truncateFR4 := !inputs.customLibrary
	hasUMIs := inputs.hasUMIs

    // [clonotypeKey] -> heavy/light property columns
    cloneColumnsHeavy := mixcrExports.cloneColumns("IGHeavy", inputs.heavyAssemblingFeature, blockId, truncateFR4)
    lightSuppressed := !is_undefined(inputs.lightImputeSequence)
    cloneColumnsLight := undefined
    if lightSuppressed {
        cloneColumnsLight = { exportArgs: [], columnSpecs: [] }
    } else {
        cloneColumnsLight = mixcrExports.cloneColumns("IGLight", inputs.lightAssemblingFeature, blockId, truncateFR4)
    }

	cloneColumnSpecs := cloneColumnsHeavy.columnSpecs + cloneColumnsLight.columnSpecs + constructColumns(inputs.linker, inputs.hinge, blockId) + clonotypeKeyLabelColumns(blockId)
	mixcrExportArgsHeavy := cloneColumnsHeavy.exportArgs
	mixcrExportArgsLight := cloneColumnsLight.exportArgs

	ll.print("__THE_LOG__ cloneColumnSpecs: " + json.encode(cloneColumnSpecs))

	// [sample, clonotypeKey] -> abundance columns
	abundanceColumns := mixcrExports.abundanceColumns(blockId, hasUMIs)
	cloneKeyAxes := abundanceColumns.cloneKeyAxes
	abundanceColumnSpecs := abundanceColumns.columnSpecs
	mainAbundanceColumn := abundanceColumns.mainAbundanceColumn
	sampleIdAxisSpec := inputSpec.axesSpec[0]


	targetOutputs := []

	clonotypeTablesOutputs := pframes.pFrameBuilder()

	for chain in ["IGHeavy", "IGLight"] {
		targetOutputs += [
			/////////////////////// QC ///////////////////////
			{
				type: "Resource",
				spec: {
					kind: "PColumn",
					valueType: "File",
					name: "mixcr.com/qc",
					domain: {
						"pl7.app/vdj/clonotypingRunId": blockId,
						"mixcr.com/scFv/chain": chain
					}
				},
				name: "qc" + chain
			},
			/////////////////////// Log ///////////////////////
			{
				type: "Resource",
				spec: {
					kind: "PColumn",
					name: "pl7.app/log",
					domain: {
						"pl7.app/vdj/clonotypingRunId": blockId,
						"mixcr.com/scFv/chain": chain
					},
					valueType: "Log"
				},
				name: "logs" + chain
			},
			/////////////////////// Reports ///////////////////////
			{
				type: "ResourceMap",
				name: "reports" + chain,
				spec: {
					kind: "PColumn",
					name: "mixcr.com/report",
					domain: {
						"pl7.app/vdj/clonotypingRunId": blockId,
						"mixcr.com/scFv/chain": chain
					},
					valueType: "File",
					axesSpec: [ {
						type: "String",
						name: "mixcr.com/report/source",
						annotations: {
							"pl7.app/label": "Source MiXCR stage"
						}
					}, {
						type: "String",
						name: "mixcr.com/report/format",
						annotations: {
							"pl7.app/label": "Report format"
						},
						domain: {
							"pl7.app/dense": string(json.encode(["json", "txt"]))
						}
					} ]
				}
			},
			/////////////////////// CLNS ///////////////////////
			{
				type: "Resource",
				spec: {
					kind: "PColumn",
					valueType: "File",
					name: "mixcr.com/clns",
					domain: {
						"pl7.app/vdj/clonotypingRunId": blockId,
						"mixcr.com/scFv/chain": chain
					}
				},
				name: "clns" + chain
			} ]
	}

	targetOutputs += [
		{
			type: "Resource",
			spec: {
				kind: "PColumn",
				name: "mixcr.com/scFv/clonotypeTable",
				domain: {
					"pl7.app/vdj/clonotypingRunId": blockId
				},
				valueType: "File"
			},
			name: "clonotypeTable",
			path: ["clonotypesTableTsv"]
		} , {
			type: "Xsv",
			xsvType: "tsv",
			settings: {
				axes: cloneKeyAxes,
				columns: abundanceColumnSpecs,
				storageFormat: "Parquet",
				partitionKeyLength: 0
			},
			name: "abundance",
			path: ["clonotypesTableTsv"]
		} ]

	mixcrResults := pframes.processColumn(
		{ spec: inputSpec, data: inputs.inputData },
		mixcrAnalyzeTpl,
		targetOutputs,
		{
			aggregate: [{
				name: "pl7.app/sequencing/lane",
				optional: true
			}, {
				name: "pl7.app/sequencing/readIndex",
				optional: true
			}],

			// resulting aggregation axes names will be checked against supported combinations
			// in the body template
			passAggregationAxesNames: true,

			// will be automatically propagated to all output specs
			traceSteps: [{type: "milaboratories.mixcr-clonotyping", id: blockId, importance: 20, label: "MiXCR - scFv"}],

			extra: {
				species: inputs.species,
				limitInput: inputs.limitInput,
				linker: inputs.linker,
				hinge: inputs.hinge,
				order: inputs.order,
				hasUMIs: hasUMIs,
				heavyTagPattern: inputs.heavyTagPattern,
				heavyAssemblingFeature: inputs.heavyAssemblingFeature,
				lightTagPattern: inputs.lightTagPattern,
				lightAssemblingFeature: inputs.lightAssemblingFeature,
				lightImputeSequence: inputs.lightImputeSequence,
				fileExtension: fileExtension,
				mixcrExportArgsHeavy: mixcrExportArgsHeavy,
				mixcrExportArgsLight: mixcrExportArgsLight,
				referenceLibraryHeavy: inputs.referenceLibraryHeavy,
				referenceLibraryLight: inputs.referenceLibraryLight,
				truncateFR4: truncateFR4,
				mixcrCpu: inputs.mixcrCpu,
				mixcrMem: inputs.mixcrMem,
				assembleScfvCpu: inputs.assembleScfvCpu,
				assembleScfvMem: inputs.assembleScfvMem,
				cloneClusteringMode: inputs.cloneClusteringMode
			}
		}
	)

	clonotypeTablesOutputs.add("clonotypeTable", mixcrResults.outputSpec("clonotypeTable"), mixcrResults.outputData("clonotypeTable"))



	aggregationOutputs := [ {
		type: "Xsv",
		xsvType: "tsv",
		settings: {
			axes: cloneKeyAxes,
			columns: cloneColumnSpecs,
			storageFormat: "Parquet",
			partitionKeyLength: 0
		},
		name: "cloneProps",
		path: ["tsv"]
	}, {
		type: "Xsv",
		xsvType: "tsv",
		settings: {
			axes: [ {
				column: "sampleId",
				spec: sampleIdAxisSpec
			}, cloneKeyAxes[0] ],
			columns: [{
				column: "link",
				spec: {
					name: "pl7.app/vdj/link",
					valueType: "Int",
					annotations: {
						"pl7.app/isLinkerColumn": "true",
						"pl7.app/label": "Sample to clonotype link",
						"pl7.app/table/visibility": "hidden",
						"pl7.app/table/orderPriority": "1"
					}
				}
			}],
			storageFormat: "Parquet",
			partitionKeyLength: 1
		},
		name: "linker",
		path: ["linker"]
	} ]

	aggByCloneKey := pframes.processColumn(
		mixcrResults.output("clonotypeTable"),
		aggClonesTpl,
		aggregationOutputs,
		{
			aggregate: ["pl7.app/sampleId"],
			extra: {
				mainAbundanceColumn: mainAbundanceColumn,
				cloneColumns: slices.map(cloneColumnSpecs, func(col) {
					return col.column
				})
			}
		}
	)

	clonotypes := pframes.pFrameBuilder()
	mixcrResults.addXsvOutputToBuilder(clonotypes, "abundance", "abundance/")
	aggByCloneKey.addXsvOutputToBuilder(clonotypes, "cloneProps", "cloneProps/")
	aggByCloneKey.addXsvOutputToBuilder(clonotypes, "linker", "linker/")
	clonotypes = clonotypes.build()

	// Create QC report table
	hasUmi := inputs.hasUMIs
	chains := ["IGHeavy", "IGLight"]
	
	qcReportTable := render.create(exportReportTpl, {
		clnsDataHeavy: mixcrResults.outputData("clnsIGHeavy"),
		clnsDataLight: mixcrResults.outputData("clnsIGLight"),
		sampleIdAxisSpec: sampleIdAxisSpec,
		chains: chains,
		clonotypeTablesData: mixcrResults.outputData("clonotypeTable"),
		hasUmi: hasUmi,
		suppressLight: lightSuppressed, 
		lightLibrary: inputs.referenceLibraryLight,
		heavyLibrary: inputs.referenceLibraryHeavy
	})

	result := {}
	for chain in ["IGHeavy", "IGLight"] {
		result["qc" + chain + ".spec"] = mixcrResults.outputSpec("qc" + chain)
		result["qc" + chain + ".data"] = mixcrResults.outputData("qc" + chain)

		result["logs" + chain + ".spec"] = mixcrResults.outputSpec("logs" + chain)
		result["logs" + chain + ".data"] = mixcrResults.outputData("logs" + chain)

		result["reports" + chain + ".spec"] = mixcrResults.outputSpec("reports" + chain)
		result["reports" + chain + ".data"] = mixcrResults.outputData("reports" + chain)
	}
	result["clonotypes"] = clonotypes
	result["clonotypeTables"] = clonotypeTablesOutputs.build()
	result["qcReportTable"] = qcReportTable.output("qcReportTable")

	return result
})

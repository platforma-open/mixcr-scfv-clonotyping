// process

self := import("@platforma-sdk/workflow-tengo:tpl")

ll := import("@platforma-sdk/workflow-tengo:ll")
assets := import("@platforma-sdk/workflow-tengo:assets")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
smart := import("@platforma-sdk/workflow-tengo:smart")
slices := import("@platforma-sdk/workflow-tengo:slices")
maps := import("@platforma-sdk/workflow-tengo:maps")
file := import("@platforma-sdk/workflow-tengo:file")
llPFrames := import("@platforma-sdk/workflow-tengo:pframes.ll")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")
pUtil := import("@platforma-sdk/workflow-tengo:pframes.util")
pConstants := import("@platforma-sdk/workflow-tengo:pframes.constants")

mixcrExports := import(":mixcr-exports")

json := import("json")
text := import("text")
render := import("@platforma-sdk/workflow-tengo:render")

mixcrAnalyzeTpl := assets.importTemplate(":mixcr-analyze")
aggClonesTpl := assets.importTemplate(":agg-clones")
exportReportTpl := assets.importTemplate(":export-report")
stopCodonReplaceTpl := assets.importTemplate(":stop-codon-replace")

self.awaitState("InputsLocked")
self.awaitState("inputSpec", "ResourceReady")

constructColumns := func(linker, hinge, blockId) {
	columns := []

	for alphabet in ["nt", "aa"] {
		columns += [{
			column: "construct-" + alphabet,
			id: "construct-" + alphabet,
			naRegex: "",
			spec: {
				name: "pl7.app/vdj/scFv-sequence",
				valueType: "String",
				domain: {
					"pl7.app/alphabet": alphabet == "nt" ? "nucleotide" : "aminoacid",
					"pl7.app/vdj/scFv-linker": linker,
					"pl7.app/vdj/scFv-hinge": hinge,
					"pl7.app/vdj/clonotypingRunId": blockId
				},
				annotations: {
					"pl7.app/label": "scFv sequence " + alphabet,
					"pl7.app/table/orderPriority": "80000",
					"pl7.app/vdj/isAssemblingFeature": "true",
					"pl7.app/vdj/isMainSequence": "true",
					"pl7.app/vdj/isAssemblingFeature": "true",
					"pl7.app/table/visibility": alphabet == "aa" ? "default" : "optional"
				}
			}
		}]

		for annotationType in ["CDRs", "Segments"] {
			columnName := (alphabet == "aa" ? "aa" : "n") + "AnnotationOf" + annotationType + "ForConstruct"
			columns += [{
				column: columnName,
				id: (alphabet == "aa" ? "aa" : "n") + "-annotation-" + text.to_lower(annotationType) + "-construct",
				naRegex: "region_not_covered",
				spec: {
					name: "pl7.app/vdj/sequence/annotation",
					valueType: "String",
					domain: {
						"pl7.app/alphabet": alphabet == "nt" ? "nucleotide" : "aminoacid",
						"pl7.app/vdj/scFv-linker": linker,
						"pl7.app/vdj/scFv-hinge": hinge,
						"pl7.app/vdj/clonotypingRunId": blockId,
						"pl7.app/sequence/annotation/type": annotationType
					},
					annotations: {
						"pl7.app/label": "scFv " + annotationType + " annotation " + alphabet,
						"pl7.app/table/orderPriority": annotationType == "CDRs" ? "79900" : "79800",
						"pl7.app/table/visibility": "optional",
						"pl7.app/sequence/annotation/mapping": mixcrExports.annotationMappings[annotationType],
						"pl7.app/sequence/isAnnotation": "true"
					}
				}
			}]
		}
	}

	columns += [{
		column: "isProductive",
		id: "isProductive",
		naRegex: "",
		spec: {
			name: "pl7.app/vdj/sequence/productive",
			valueType: "String",
			domain: {
				"pl7.app/vdj/scFv-linker": linker,
				"pl7.app/vdj/scFv-hinge": hinge,
				"pl7.app/vdj/clonotypingRunId": blockId
			},
			annotations: {
				"pl7.app/label": "Productive",
				"pl7.app/table/orderPriority": "40000",
				"pl7.app/isDiscreteFilter": "true",
				"pl7.app/discreteValues": string(json.encode(["true", "false"])),
				"pl7.app/table/visibility": "optional"
			}
		}
	}]

	return columns
}

clonotypeKeyLabelColumns := func(blockId) {
	return [{
		column: "clonotypeLabel",
		id: "clonotypeLabel",
		naRegex: "",
		spec: {
			name: "pl7.app/label",
			valueType: "String",
			domain: {
				"pl7.app/vdj/clonotypingRunId": blockId
			},
			annotations: {
				"pl7.app/label": "scFv label",
				"pl7.app/table/visibility": "default"
				//"pl7.app/table/orderPriority": "200000"
			}
		}
	}]
}

self.body(func(inputs) {

	inputSpec := inputs.inputSpec
	blockId := inputs.blockId

	fileExtension := inputSpec.domain["pl7.app/fileExtension"]

	truncateFR4 := !inputs.customLibrary
	hasUMIs := inputs.hasUMIs
	stopCodonTypes := inputs.stopCodonTypes
	stopCodonReplacements := inputs.stopCodonReplacements

    // [clonotypeKey] -> heavy/light property columns
    cloneColumnsHeavy := mixcrExports.cloneColumns("IGHeavy", inputs.heavyAssemblingFeature, blockId, truncateFR4)
    lightSuppressed := !is_undefined(inputs.lightImputeSequence)
    cloneColumnsLight := undefined
    if lightSuppressed {
        cloneColumnsLight = { exportArgs: [], columnSpecs: [] }
    } else {
        cloneColumnsLight = mixcrExports.cloneColumns("IGLight", inputs.lightAssemblingFeature, blockId, truncateFR4)
    }

	cloneColumnsPerSample := cloneColumnsHeavy.columnSpecs + cloneColumnsLight.columnSpecs + constructColumns(inputs.linker, inputs.hinge, blockId) + clonotypeKeyLabelColumns(blockId)
	aggregateColumns := mixcrExports.aggregateColumns(hasUMIs)
	cloneColumnSpecs := cloneColumnsPerSample + aggregateColumns
	mixcrExportArgsHeavy := cloneColumnsHeavy.exportArgs
	mixcrExportArgsLight := cloneColumnsLight.exportArgs

	ll.print("__THE_LOG__ cloneColumnSpecs: " + json.encode(cloneColumnSpecs))

	aminoAcidSeqColumns := []
	cdr3SeqColumns := []
	for colSpec in cloneColumnSpecs {
		spec := colSpec.spec
		if is_undefined(spec) {
			continue
		}
		if spec.name == "pl7.app/vdj/sequence" {
			if spec.domain["pl7.app/alphabet"] == "aminoacid" {
				aminoAcidSeqColumns += [ colSpec.column ]
			}
			if spec.domain["pl7.app/vdj/feature"] == "CDR3" {
				cdr3SeqColumns += [ colSpec.column ]
			}
		} else if spec.name == "pl7.app/vdj/scFv-sequence" {
			if spec.domain["pl7.app/alphabet"] == "aminoacid" {
				aminoAcidSeqColumns += [ colSpec.column ]
			}
		}
	}

	// [sample, clonotypeKey] -> abundance columns
	abundanceColumns := mixcrExports.abundanceColumns(blockId, hasUMIs)
	cloneKeyAxes := abundanceColumns.cloneKeyAxes
	abundanceColumnSpecs := abundanceColumns.columnSpecs
	mainAbundanceColumn := abundanceColumns.mainAbundanceColumn
	mainAbundanceColumnNormalized := abundanceColumns.mainAbundanceColumnNormalized
	mainAbundanceColumnUnnormalized := abundanceColumns.mainAbundanceColumnUnnormalized


	targetOutputs := []

	clonotypeTablesOutputs := pframes.pFrameBuilder()

	for chain in ["IGHeavy", "IGLight"] {
		targetOutputs += [
			/////////////////////// QC ///////////////////////
			{
				type: "Resource",
				spec: {
					kind: "PColumn",
					valueType: "File",
					name: "mixcr.com/qc",
					domain: {
						"pl7.app/vdj/clonotypingRunId": blockId,
						"mixcr.com/scFv/chain": chain
					}
				},
				name: "qc" + chain
			},
			/////////////////////// Log ///////////////////////
			{
				type: "Resource",
				spec: {
					kind: "PColumn",
					name: "pl7.app/log",
					domain: {
						"pl7.app/vdj/clonotypingRunId": blockId,
						"mixcr.com/scFv/chain": chain
					},
					valueType: "Log"
				},
				name: "logs" + chain
			},
			/////////////////////// Reports ///////////////////////
			{
				type: "ResourceMap",
				name: "reports" + chain,
				spec: {
					kind: "PColumn",
					name: "mixcr.com/report",
					domain: {
						"pl7.app/vdj/clonotypingRunId": blockId,
						"mixcr.com/scFv/chain": chain
					},
					valueType: "File",
					axesSpec: [ {
						type: "String",
						name: "mixcr.com/report/source",
						annotations: {
							"pl7.app/label": "Source MiXCR stage"
						}
					}, {
						type: "String",
						name: "mixcr.com/report/format",
						annotations: {
							"pl7.app/label": "Report format"
						},
						domain: {
							"pl7.app/dense": string(json.encode(["json", "txt"]))
						}
					} ]
				}
			},
			/////////////////////// CLNS ///////////////////////
			{
				type: "Resource",
				spec: {
					kind: "PColumn",
					valueType: "File",
					name: "mixcr.com/clns",
					domain: {
						"pl7.app/vdj/clonotypingRunId": blockId,
						"mixcr.com/scFv/chain": chain
					}
				},
				name: "clns" + chain
			} ]
	}

	clonotypeTableOutput := {
		type: "Resource",
		spec: {
			kind: "PColumn",
			name: "mixcr.com/scFv/clonotypeTable",
			domain: {
				"pl7.app/vdj/clonotypingRunId": blockId
			},
			valueType: "File"
		},
		name: "clonotypeTable",
		path: ["clonotypesTableTsv"]
	}

	targetOutputs += [
		clonotypeTableOutput, {
			type: "Xsv",
			xsvType: "tsv",
			settings: {
				axes: cloneKeyAxes,
				columns: abundanceColumnSpecs,
				storageFormat: "Parquet",
				partitionKeyLength: 0
			},
			name: "abundance",
			path: ["clonotypesTableTsv"]
		} ]

	mixcrResults := pframes.processColumn(
		{ spec: inputSpec, data: inputs.inputData },
		mixcrAnalyzeTpl,
		targetOutputs,
		{
			aggregate: [{
				name: "pl7.app/sequencing/lane",
				optional: true
			}, {
				name: "pl7.app/sequencing/readIndex",
				optional: true
			}],

			// resulting aggregation axes names will be checked against supported combinations
			// in the body template
			passAggregationAxesNames: true,

			// will be automatically propagated to all output specs
			traceSteps: [{type: "milaboratories.mixcr-clonotyping", id: blockId, importance: 20, label: "MiXCR - scFv"}],

			extra: {
				species: inputs.species,
				limitInput: inputs.limitInput,
				linker: inputs.linker,
				hinge: inputs.hinge,
				order: inputs.order,
				hasUMIs: hasUMIs,
				heavyTagPattern: inputs.heavyTagPattern,
				heavyAssemblingFeature: inputs.heavyAssemblingFeature,
				lightTagPattern: inputs.lightTagPattern,
				lightAssemblingFeature: inputs.lightAssemblingFeature,
				lightImputeSequence: inputs.lightImputeSequence,
				fileExtension: fileExtension,
				stopCodonTypes: stopCodonTypes,
				mixcrExportArgsHeavy: mixcrExportArgsHeavy,
				mixcrExportArgsLight: mixcrExportArgsLight,
				referenceLibraryHeavy: inputs.referenceLibraryHeavy,
				referenceLibraryLight: inputs.referenceLibraryLight,
				truncateFR4: truncateFR4,
				mixcrCpu: inputs.mixcrCpu,
				mixcrMem: inputs.mixcrMem,
				assembleScfvCpu: inputs.assembleScfvCpu,
				assembleScfvMem: inputs.assembleScfvMem,
				cloneClusteringMode: inputs.cloneClusteringMode
			}
		}
	)

	clonotypeTableColumn := mixcrResults.output("clonotypeTable")
	clonotypeTableSpec := mixcrResults.outputSpec("clonotypeTable")
	clonotypeTableData := mixcrResults.outputData("clonotypeTable")
	if !is_undefined(stopCodonTypes) && len(stopCodonTypes) > 0 {
		stopCodonResults := pframes.processColumn(
			clonotypeTableColumn,
			stopCodonReplaceTpl,
			[ clonotypeTableOutput ],
			{
				extra: {
					params: maps.clone({
						aminoAcidSeqColumns: aminoAcidSeqColumns,
						cdr3SeqColumns: cdr3SeqColumns,
						stopCodonTypes: stopCodonTypes,
						stopCodonReplacements: stopCodonReplacements
					}, { removeUndefs: true })
				}
			}
		)
		clonotypeTableColumn = stopCodonResults.output("clonotypeTable")
		clonotypeTableSpec = stopCodonResults.outputSpec("clonotypeTable")
		clonotypeTableData = stopCodonResults.outputData("clonotypeTable")
	}

	clonotypeTablesOutputs.add("clonotypeTable", clonotypeTableSpec, clonotypeTableData)



	aggregationOutputs := [ {
		type: "Xsv",
		xsvType: "tsv",
		settings: {
			axes: cloneKeyAxes,
			columns: cloneColumnSpecs,
			storageFormat: "Parquet",
			partitionKeyLength: 0
		},
		name: "cloneProps",
		path: ["tsv"]
	} ]

	aggByCloneKey := pframes.processColumn(
		clonotypeTableColumn,
		aggClonesTpl,
		aggregationOutputs,
		{
			aggregate: ["pl7.app/sampleId"],
			extra: {
				mainAbundanceColumnNormalized: mainAbundanceColumnNormalized,
				mainAbundanceColumnUnnormalized: mainAbundanceColumnUnnormalized,
				cloneColumnSpecs: cloneColumnsPerSample,
				cloneColumns: slices.map(cloneColumnsPerSample, func(col) {
					return col.column
				})
			}
		}
	)

	clonotypes := pframes.pFrameBuilder()
	mixcrResults.addXsvOutputToBuilder(clonotypes, "abundance", "abundance/")
	aggByCloneKey.addXsvOutputToBuilder(clonotypes, "cloneProps", "cloneProps/")
	clonotypes = clonotypes.build()

	// Create QC report table
	sampleIdAxisSpec := inputSpec.axesSpec[0]
	hasUmi := inputs.hasUMIs
	chains := ["IGHeavy", "IGLight"]
	
	qcReportTable := render.create(exportReportTpl, {
		clnsDataHeavy: mixcrResults.outputData("clnsIGHeavy"),
		clnsDataLight: mixcrResults.outputData("clnsIGLight"),
		sampleIdAxisSpec: sampleIdAxisSpec,
		chains: chains,
		clonotypeTablesData: clonotypeTableData,
		hasUmi: hasUmi,
		suppressLight: lightSuppressed, 
		lightLibrary: inputs.referenceLibraryLight,
		heavyLibrary: inputs.referenceLibraryHeavy
	})

	result := {}
	for chain in ["IGHeavy", "IGLight"] {
		result["qc" + chain + ".spec"] = mixcrResults.outputSpec("qc" + chain)
		result["qc" + chain + ".data"] = mixcrResults.outputData("qc" + chain)

		result["logs" + chain + ".spec"] = mixcrResults.outputSpec("logs" + chain)
		result["logs" + chain + ".data"] = mixcrResults.outputData("logs" + chain)

		result["reports" + chain + ".spec"] = mixcrResults.outputSpec("reports" + chain)
		result["reports" + chain + ".data"] = mixcrResults.outputData("reports" + chain)
	}
	result["clonotypes"] = clonotypes
	result["clonotypeTables"] = clonotypeTablesOutputs.build()
	result["qcReportTable"] = qcReportTable.output("qcReportTable")

	return result
})

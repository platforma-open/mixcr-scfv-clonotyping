// "hello world"
wf := import("@platforma-sdk/workflow-tengo:workflow")
exec := import("@platforma-sdk/workflow-tengo:exec")
assets:= import("@platforma-sdk/workflow-tengo:assets")
render := import("@platforma-sdk/workflow-tengo:render")
maps := import("@platforma-sdk/workflow-tengo:maps")
smart := import("@platforma-sdk/workflow-tengo:smart")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
ll := import("@platforma-sdk/workflow-tengo:ll")
text := import("text")

processTpl := assets.importTemplate(":process")
repseqioLibraryTpl := assets.importTemplate(":repseqio-library")


tagPatternHasUMIs := func(tagPattern) {
	if is_undefined(tagPattern) {
		return false
	}
	return text.contains(tagPattern, "UMI") ||
		   text.contains(tagPattern, "Umi") ||
		   text.contains(tagPattern, "umi")
}

wf.body(func(args) {
	input := wf.resolve(args.input)

	// Optional per-chain reference libraries (only if both V and J provided)
	referenceLibraryHeavy := undefined
	referenceLibraryLight := undefined

	customLibrary := false

	if args.customRefMode != "builtin" &&
	   !is_undefined(args.heavyVGenes) &&
	   !is_undefined(args.heavyJGenes) &&
	   args.heavyVGenes != "" &&
	   args.heavyJGenes != "" {

		customLibrary = true
		heavyFiles := exec.builder().cmd("/usr/bin/env").arg("bash").
			writeFile("heavyV.fasta", args.heavyVGenes).saveFile("heavyV.fasta").
			writeFile("heavyJ.fasta", args.heavyJGenes).saveFile("heavyJ.fasta").
			run()
		referenceLibraryHeavyCmd := render.create(repseqioLibraryTpl, {
			vGeneFasta: heavyFiles.getFile("heavyV.fasta"),
			jGeneFasta: heavyFiles.getFile("heavyJ.fasta"),
			chains: "IGH"
		})
		referenceLibraryHeavy = referenceLibraryHeavyCmd.output("referenceLibrary")
	}

	if args.customRefMode != "builtin" &&
	  !is_undefined(args.lightVGenes) &&
	  !is_undefined(args.lightJGenes) &&
	  args.lightVGenes != "" &&
	  args.lightJGenes != "" {

		customLibrary = true
		lightFiles := exec.builder().cmd("/usr/bin/env").arg("bash").
			writeFile("lightV.fasta", args.lightVGenes).saveFile("lightV.fasta").
			writeFile("lightJ.fasta", args.lightJGenes).saveFile("lightJ.fasta").
			run()
		referenceLibraryLightCmd := render.create(repseqioLibraryTpl, {
			vGeneFasta: lightFiles.getFile("lightV.fasta"),
			jGeneFasta: lightFiles.getFile("lightJ.fasta"),
			chains: "IGK"
		})
		referenceLibraryLight = referenceLibraryLightCmd.output("referenceLibrary")
	}
	// keep separate heavy/light libraries; do not merge

hUmi := tagPatternHasUMIs(args.heavyTagPattern)
lUmi := tagPatternHasUMIs(args.lightTagPattern)
hasUMIs := hUmi || lUmi
// Only enforce mismatch when both tag patterns are provided
if !is_undefined(args.heavyTagPattern) && !is_undefined(args.lightTagPattern) {
	if hasUMIs && (!hUmi || !lUmi){
		ll.panic("UMI tag pattern is present in one chain but not the other")
	}
}

	runMixcr := render.createEphemeral(processTpl, {
		inputSpec: input.getFutureInputField("spec"),
		inputData: input.getFutureInputField("data"),
		customLibrary: customLibrary,
		species: args.species,
		linker: args.linker,
		hinge: args.hinge,
		order: args.order,
		hasUMIs: hasUMIs,
		heavyTagPattern: args.heavyTagPattern,
  		heavyAssemblingFeature: args.heavyAssemblingFeature,
  		lightTagPattern: args.lightTagPattern,
  		lightAssemblingFeature: args.lightAssemblingFeature,
		blockId: wf.blockId().getDataAsJson(),
		limitInput: args.limitInput,
		referenceLibraryHeavy: referenceLibraryHeavy,
		referenceLibraryLight: referenceLibraryLight,
		mixcrCpu: args.mixcrCpu,
		mixcrMem: args.mixcrMem,
		assembleScfvCpu: args.assembleScfvCpu,
		assembleScfvMem: args.assembleScfvMem,
		lightImputeSequence: args.lightImputeSequence,
		cloneClusteringMode: args.cloneClusteringMode
	})

	exports := {
		clones: runMixcr.output("clonotypes")
	}

	outputs := {}
	for chain in ["IGHeavy", "IGLight"] {
		outputs["logs" + chain] = runMixcr.output("logs" + chain + ".data")
		outputs["qc" + chain] = pframes.exportColumnData(runMixcr.output("qc" + chain + ".data"))
		outputs["reports" + chain ] = pframes.exportColumnData(runMixcr.output("reports" + chain + ".data"))
	}

	// Expose combined clonotype tables frame for UI raw exports (same shape as amplicon alignment)
	outputs["clonotypeTables"] = pframes.exportFrame(runMixcr.output("clonotypeTables"))

	qcReportTable := runMixcr.output("qcReportTable")
	outputs["qcReportTable"] = pframes.exportFrame(qcReportTable)

	return {
		outputs: outputs,
		exports: exports
	}
})
